<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Twitch Countdown Timer</title>

    <!-- 1. REQUIRED: Include the Twitch Extension Helper -->
    <script src="https://extension-files.twitch.tv/helper/v1/twitch-ext.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --accent-color: #00d5ff;
            --background-color: #18181b;
            --text-color: #ffffff;
            --muted-color: #8d939a;
            --panel-width: 320px;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            width: var(--panel-width);
            height: auto;
            box-sizing: border-box;
            text-align: center;
            padding: 20px 10px;
            position: relative;
            overflow: hidden;
        }

        body::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 150px;
            height: 150px;
            transform: translate(-50%, -50%);
            background-image: url('https://haydenprice.github.io/StreamTools/images/fishy.png'); /* Replace with your logo URL */
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.1;
            z-index: 0;
        }

        .container {
            position: relative;
            z-index: 1;
        }

        .countdown-labels {
            display: flex;
            justify-content: space-around;
            padding: 0 15px;
            margin-bottom: 5px;
        }

        .countdown-labels span {
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            color: var(--muted-color);
            width: 50px;
        }

        #countdown-value {
            font-size: 42px;
            font-weight: 900;
            color: var(--accent-color);
            text-shadow: 0 0 10px var(--accent-color), 0 0 20px rgba(0, 213, 255, 0.5);
            letter-spacing: 2px;
            margin-bottom: 15px;
        }

        #subtitle {
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--muted-color);
            margin-bottom: 30px;
        }

        #weekly-schedule {
            display: flex;
            justify-content: space-between;
            width: 100%;
        }

        .day-block {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 11px;
            width: calc(100% / 7);
            color: var(--muted-color);
        }

        .day-block .dot {
            width: 6px;
            height: 6px;
            background-color: #4d4d53;
            border-radius: 50%;
            margin-bottom: 8px;
        }

        .day-block .day-name {
            font-weight: 700;
            margin-bottom: 6px;
        }

        .day-block .times {
            font-size: 10px;
            line-height: 1.4;
        }

        .day-block.active {
            color: var(--text-color);
        }

        .day-block.active .dot {
            background-color: var(--accent-color);
            box-shadow: 0 0 8px var(--accent-color);
        }

        #message-container {
            font-size: 24px;
            font-weight: 700;
            display: none;
            padding: 50px 0;
        }

        #message-container.live {
            color: #10e064;
            text-shadow: 0 0 10px #10e064;
        }

    </style>
</head>
<body>

<div class="container">
    <div class="countdown-labels">
        <span>Days</span>
        <span>Hours</span>
        <span>Minutes</span>
        <span>Seconds</span>
    </div>
    <div id="countdown-value">--:--:--:--</div>
    <p id="subtitle">Countdown to the next stream</p>

    <div id="weekly-schedule">
        <!-- Weekly schedule will be populated by JavaScript -->
    </div>

    <div id="message-container"></div>
</div>

<script>
    // Store a reference to the main countdown interval so we can clear it
    let countdownInterval = null;

    // Get references to DOM elements
    const countdownValueEl = document.getElementById('countdown-value');
    const weeklyScheduleEl = document.getElementById('weekly-schedule');
    const subtitleEl = document.getElementById('subtitle');
    const containerEl = document.querySelector('.container');
    const messageContainerEl = document.getElementById('message-container');

    // This function now takes the schedule as an argument
    function findNextStreamDate(schedule) {
        const now = new Date();
        let nextStream = null;
        const potentialDates = [];

        if (!schedule || schedule.length === 0) {
            return null;
        }

        schedule.forEach(stream => {
            const streamTime = stream.time.split(':');
            const streamHour = parseInt(streamTime[0], 10);
            const streamMinute = parseInt(streamTime[1], 10);
            let nextDate = new Date();
            nextDate.setHours(streamHour, streamMinute, 0, 0);
            let dayDifference = stream.day - now.getDay();
            if (dayDifference < 0 || (dayDifference === 0 && nextDate.getTime() < now.getTime())) {
                dayDifference += 7;
            }
            nextDate.setDate(now.getDate() + dayDifference);
            potentialDates.push(nextDate);
        });

        potentialDates.sort((a, b) => a - b);
        return potentialDates.length > 0 ? potentialDates[0] : null;
    }

    // This function now takes the schedule as an argument
    function populateWeeklySchedule(schedule, activeDay) {
        weeklyScheduleEl.innerHTML = '';
        const dayNames = ["SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"];

        for (let i = 0; i < 7; i++) {
            const dayBlock = document.createElement('div');
            dayBlock.classList.add('day-block');
            if (i === activeDay) {
                dayBlock.classList.add('active');
            }

            const streamsOnThisDay = schedule ? schedule.filter(s => s.day === i) : [];

            const dot = document.createElement('div');
            dot.classList.add('dot');
            const dayName = document.createElement('div');
            dayName.classList.add('day-name');
            dayName.textContent = dayNames[i];
            const times = document.createElement('div');
            times.classList.add('times');

            if (streamsOnThisDay.length > 0) {
                streamsOnThisDay.forEach(s => {
                    times.innerHTML += `<div>${s.time}</div>`;
                });
            } else {
                times.innerHTML = '<div>-</div>';
            }

            dayBlock.appendChild(dot);
            dayBlock.appendChild(dayName);
            dayBlock.appendChild(times);
            weeklyScheduleEl.appendChild(dayBlock);
        }
    }

    // This function now takes the schedule as an argument
    function runCountdown(schedule) {
        // Clear any previous countdown
        if (countdownInterval) {
            clearInterval(countdownInterval);
        }

        const nextStreamDate = findNextStreamDate(schedule);

        if (!nextStreamDate) {
            containerEl.style.display = 'none';
            messageContainerEl.style.display = 'block';
            messageContainerEl.textContent = "No streams scheduled!";
            populateWeeklySchedule([], -1); // Show an empty schedule
            return;
        }

        // Show the main container if it was hidden
        containerEl.style.display = 'block';
        messageContainerEl.style.display = 'none';

        populateWeeklySchedule(schedule, nextStreamDate.getDay());

        countdownInterval = setInterval(() => {
            const now = new Date().getTime();
            const distance = nextStreamDate.getTime() - now;

            if (distance < 0) {
                clearInterval(countdownInterval);
                containerEl.style.display = 'none';
                messageContainerEl.style.display = 'block';
                messageContainerEl.classList.add('live');
                messageContainerEl.textContent = "I'M LIVE NOW!";
                // After a while, check for the next stream again
                setTimeout(() => runCountdown(schedule), 60000);
                return;
            }

            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);

            const format = (num) => String(num).padStart(2, '0');
            countdownValueEl.textContent = `${format(days)}:${format(hours)}:${format(minutes)}:${format(seconds)}`;

        }, 1000);
    }

    // --- 2. TWITCH EXTENSION LOGIC ---

    // This function is called when the extension is authorized by Twitch
    window.Twitch.ext.onAuthorized(function(auth) {
        // This is where you would get the broadcaster's saved configuration
        const broadcasterConfig = window.Twitch.ext.configuration.broadcaster;

        let schedule = [];
        if (broadcasterConfig && broadcasterConfig.content) {
            try {
                // The config is stored as a string, so we need to parse it
                const config = JSON.parse(broadcasterConfig.content);
                if (config.schedule) {
                    schedule = config.schedule;
                }
            } catch (e) {
                console.error("Error parsing broadcaster config:", e);
            }
        }

        // Start the countdown with the schedule from the config
        runCountdown(schedule);
    });

    // This function is called whenever the broadcaster saves a new configuration
    window.Twitch.ext.configuration.onChanged(function() {
        const broadcasterConfig = window.Twitch.ext.configuration.broadcaster;

        let schedule = [];
        if (broadcasterConfig && broadcasterConfig.content) {
            try {
                const config = JSON.parse(broadcasterConfig.content);
                if (config.schedule) {
                    schedule = config.schedule;
                }
            } catch (e) {
                console.error("Error parsing broadcaster config:", e);
            }
        }

        // Restart the countdown with the new schedule
        runCountdown(schedule);
    });

</script>
</body>
</html>
